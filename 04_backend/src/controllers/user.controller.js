import { asyncHandler } from "../utils/asyncHandler.js";
import { apiError } from "../utils/apiError.js";
import { User } from "../models/user.model.js";
import { uploadOnCloudinary } from "../utils/cloudinary.js";
import { apiResponse } from "../utils/apiResponse.js";
import jwt  from "jsonwebtoken";
import mongoose from "mongoose";

// making a jwt for the user and saving refresh token to the database of that user
const generateAccessTokenAndRefreshAccessToken = async (userId) => {
  try {
    const user = await User.findById(userId);
    const accessToken = user.generateAccessToken();
    const refreshToken = user.generateRefreshToken();

    //    adding refreshToken
    user.refreshToken = refreshToken;

    // saving in db
    // await user.save(); //  to save the user with validation
    await user.save({ validateBeforeSave: false }); //to skip validation before saving

    return { accessToken, refreshToken };
  } catch (error) {
    throw new apiError(
      500,
      "Something went wrong generating access and refresh token"
    );
  }
};

const registerUser = asyncHandler(async (req, res) => {
  //just for testing
  // res.status(200).json({
  //     message: "ARIF AKHTAR"
  // })

  // real code
  //get user details from frontend:-
  const { username, fullname, email, password } = req.body;
  // console.table([
  //     { "Field": "username", "Value": username },
  //     { "Field": "fullname", "Value": fullname },
  //     { "Field": "email", "Value": email },
  //     { "Field": "password", "Value": password } // For security reasons, avoid displaying the actual password
  //   ]);
  // console.log(req.body);

  // validation - not empty:-
  //   if (!username || !password || !fullname || !email ) {
  //       return res.status(400).send("Please fill all fields");
  //   } // generated by copilot

  // if (fullname === "") {
  //     throw new apiError(400, "Fullname is required")
  // }
  // checking all one at once
  if (
    [username, fullname, email, password].some((field) => field?.trim() === "")
  ) {
    throw new apiError(400, "All fields are required");
  } //The some method checks if at least one element in the array satisfies the condition inside the callback function.

  //checking if the user already exists in the database or not
  let existedUser = await User.findOne({
    // $or:[ {'username': username},{'email': email}] // generated by copilot
    $or: [{ username }, { email }],
  });
  //   console.log("existedUser:", existedUser);
  if (existedUser) {
    throw new apiError(409, "User with email or username already exists");
  }

  // check for images
  // console.log("Files:"  ,req.files ); //Multer adds a body object and a file or files object to the request object
  const avatarLocalPath = req.files?.avatar[0]?.path; //accesses the path property using files method

  let coverImageLocalPath;
  if (
    req.files &&
    Array.isArray(req.files.coverImage) &&
    req.files.coverImage.length > 0
  ) {
    coverImageLocalPath = req.files.coverImage[0].path;
  }
  // const coverImageLocalPath = req.files?.coverImage?.[0]?.path ?? '' //above code in one line by entrying empty string if not coverImage available
  // console.log([avatarLocalPath, coverImageLocalPath]);

  // check for avatar:-
  if (!avatarLocalPath) {
    throw new apiError(400, "Avatar file is required");
  }

  // upload to cloudinary:-
  const avatar = await uploadOnCloudinary(avatarLocalPath);
  const coverImage = await uploadOnCloudinary(coverImageLocalPath);

  // console.log("avatar cloudinary", avatar);
  if (!avatar) {
    throw new apiError(400, "Avatar file is required on cloudinary");
  }

  // create user object - create entry in db:-
  const user = await User.create({
    fullname,
    avatar: avatar.url,
    coverImage: coverImage?.url || "",
    email,
    password,
    username: username.toLowerCase(),
  });

  // remove password and refresh token
  const createdUser = await User.findById(user._id).select(
    "-password -refreshToken"
  ); // This is a common pattern to retrieve a user from the database without including sensitive information such as passwords or refresh tokens.

  // to check user created or not
  if (!createdUser) {
    throw new apiError(500, "Something went wrong while registering the user!");
  }

  // if created return response
  // return res.status(201).json({createdUser})
  // better approach by using premade template to response "apiResponse"
  return res
    .status(201)
    .json(new apiResponse(200, createdUser, "User Registered successfully"));
});

const loginUser = asyncHandler(async (req, res) => {
  // get data from req body
  const { username, email, password } = req.body;
  console.log("req.body: ", username, email, password);

  // username or login
  // if (!username || !email) {
  //   throw apiError(400, "username and email is required");
  // } //  checks if either username or login is falsy

  if (!username && !email) {
    throw apiError(400, "username or email is required");
  } //  checks if both username and login is falsy

  // if (!(username || email)) {
  //   throw apiError(400, "username or email is required");
  // } // checks if both username and login is falsy

  // find the user
  const user = await User.findOne({
    $or: [{ username }, { email }],
  });
  // if not registered
  if (!user) {
    throw apiError(404, "user does not exist");
  }

  // password checking
  const isPasswordMatch = await user.isPasswordCorrect(password); // here using user not User

  // if invalid password
  if (!isPasswordMatch) {
    throw apiError(401, "Invalid user credentials");
  }
  //calling to make a jwt (accesss and refresh token)
  const { accessToken, refreshToken } =
    await generateAccessTokenAndRefreshAccessToken(user._id);

  // one more db call since user got new value like refresh token
  const loggedInUser = await User.findById(user._id).select("-password -refreshToken"); //no need to get password and refreshToken for security

  // Send Cookie:-
  const options = {
    httpOnly: true, //When set to true, the cookie is not accessible through JavaScript in the browse
    secure: true, // When set to true, the cookie will only be sent over HTTPS connections.
  };

  return res
    .status(200)
    .cookie("accessToken", accessToken)
    .cookie("refreshToken", refreshToken)
    .json(
      new apiResponse(
        200,
        {
          user: loggedInUser,
          accessToken,
          refreshToken, //send again both token if user wants to save or for mobile apps whe
        },
        "User logged successfully"
      )
    );
});

const logoutUser = asyncHandler(async (req, res) => {
  // removing refreshToken of that user in db
  // User.findById(req.user._id) //this will retreve all data including credentials too
  await User.findByIdAndUpdate(
    req.user._id,
    {
      // $set: {
      //   refreshToken: undefined,
      //   refreshToken: null,
      // },
       // it's more appropriate to use $unset with the value set to 1:

      $unset: {
        refreshToken: 1,
      }
    },
    { new: true }
  );
  //clearing cookies from client side

  // Send Cookie:-
  const options = {
    httpOnly: true, //When set to true, the cookie is not accessible through JavaScript in the browse
    secure: true, // When set to true, the cookie will only be sent over HTTPS connections.
  };

  return res
  .status(200)
  .clearCookie("accessToken", options)
  .clearCookie("refreshToken", options)
  .json(new apiResponse(200, {}, "User logged out!"))



});


const refreshAccessToken = asyncHandler(async (req, res)=>{
  const incomingRefreshToken = req.cookies.refreshToken || req.body.refreshToken

  if (!incomingRefreshToken) {
    throw new apiError(401, "Invalid refresh token, unauthorized request")
  }

  try {
    // we have to verify  the refresh token first because its encrypted in client side and serverside
    const decodedToken = jwt.verify(incomingRefreshToken,  process.env.REFRESH_TOKEN_SECRET)
  
    // after got decoded token we can find  user by its id because it also contain payload / data
    let user = await User.findById(decodedToken._id)
    console.log("user:", user);
  
    if (!user) {
      throw new apiError(401,'No such user present in the database, unauthorized request')
    }
  
    if (incomingRefreshToken !== user?.refreshToken){
      throw new apiError(401, "refresh token is expired or used")
    }
      
    const {accessToken, refreshToken} = await generateAccessTokenAndRefreshAccessToken(user._id)
  
  
    const options = {
      httpOnly: true,
      secure: true
    }
  
    return res
    .status(200)
    .cookie("accessToken", accessToken)
    .cookie("refreshToken", refreshToken)
    .json(new apiResponse(
      200,
       {accessToken,  refreshToken},
      "Access  Token has been Refreshed"
     ))
  } catch (error) {
    throw new apiError(401, error?.message || "Access  Token refresh failed")
  }














})

const changeCurrentPassword = asyncHandler(async(req, res)=>{
  const {oldPassword, newPassword, } = req.body

  // Retrieve the user from the database
  const user = await User.findById(req.user?._id)
  console.log("user", user);
  if (!user) {
   throw new apiError(400, "User not found")
  }

  // Check if the entered old password is correct
  const isPasswordCorrect = await user.isPasswordCorrect(oldPassword)
  if(!isPasswordCorrect){
    throw new apiError(400,"Old password is incorrect ")
  }

  // Update the user's password with the new one
  user.password = newPassword
  await user.save({validateBeforeSave: false})

  return res
  .status(200)
  .json(new apiResponse(200, {}, "Password  changed successfully"))





})

const getCurrentUser = asyncHandler(async(req, res)=> {
  return res
  .status(200)
  .json( new apiResponse(200, req.user, "Current User Fetch Successfully"))
})

const updateAccountDetails = asyncHandler(async(req, res)=>{
  const {fullname, email} = req.body

  if(!fullname || !email){
    throw new apiError(400, "All fields are required")
  }
  const user = await User.findByIdAndUpdate(
    req.user?._id,
    {
      $set: {
        // fullname: fullname,
        // email: email
        fullname,
        email
      }
    }, 
    {new: true}
    ).select("-password")

    return res
    .status(200)
    .json(new apiResponse(200,  user,  'User details updated'))



})

const updateUserAvatar = asyncHandler(async(req, res)=> {

  console.log("reqqqq`", req);
  const avatarLocalPath = req.file?.path
  console.log("avatarLocalPath", avatarLocalPath);
  if (!avatarLocalPath) {
    throw new apiError(400, "No Avatar file uploaded");
  }

  const avatar = await uploadOnCloudinary(avatarLocalPath)
  if (!avatar.url) {
    throw new apiError(400, "Error while uploading avatar")
  }
  const user = await User.findByIdAndUpdate(
    req.user?._id,
    {
      $set:{
        avatar: avatar.url
      }
    } ,
    {new: true}
    ).select("-password")

    return res
    .status(200)
    .json(new apiResponse(200,  user,  'User avatar updated'))

})
const updateUserCoverImage = asyncHandler(async(req, res)=> {

  const coverImageLocalPath = req.file?.path
  if (!coverImageLocalPath) {
    throw new apiError(400, "No coverImage file uploaded");
  }

  const coverImage = await uploadOnCloudinary(coverImageLocalPath)
  if (!coverImage.url) {
    throw new apiError(400, "Error while uploading cover Image")
  }
  const user = await User.findByIdAndUpdate(
    req.user?._id,
    {
      $set:{
        coverImage: coverImage.url
      }
    } ,
    {new: true}
    ).select("-password")

    //TODO: Delete old avatar image  on cloudinary after saving it to cloudinary

    return res
    .status(200)
    .json(new apiResponse(200,  user,  'User coverImage updated'))

})

const getUserChannelProfile = asyncHandler(async(req, res)=>{
  const {username} = req.params // an object containing properties mapped to the named route parameters
  if(!username?.trim()){
    throw new apiError(400,"Username is missing")
  }
  //const channel = await User.find({username}) //we are searching and adding pipline in one db call 

  const channel = await User.aggregate([
    {
      $match: {
        username: username?.toLowerCase()
      }
    },
    {
      $lookup: {
        from: "subscriptions",  // all model convert to plural and lower case in db
        localField: "_id",
        foreignField: "channel",
        as: "subscribers" 
      }
    },
    {
      $lookup: {
        from: "subscriptions",  // all model convert to plural and lower case in db
        localField: "_id",
        foreignField: "subscriber",
        as: "subscribedTo"
      }
    },
    {
      $addFields:{
        subscribersCount: {$size:"$subscribers"},
        channelSubscribedToCount: {$size: "$subscribedTo"},
        isSubscribed: {
          if:{$in: [req.user?._id, "$subscribers.subscriber"]},
          then: true,
          else: false
        }
      }
    },
    {
      $project: {
        fullname: 1,
        username: 1,
        subscribersCount: 1,
        channelSubscribedToCount: 1,
        isSubscribed: 1,
        avatar: 1,
        coverImage: 1,
        email: 1

      }
    }
  ])
  console.log("channel", channel);

  if(!channel?.length){
    throw new apiError(404, "Channel does not exist")
  }
    return res.status(200).json(
      new apiResponse(200, channel[0], "User channel fetch successfully")
    )


})

const getWatchHistory = asyncHandler(async(req, res)=>{
  const user = await User.aggregate([
    {
      $match: { _id : new mongoose.Types.ObjectId(req.user._id)} //req.user._id is a string representation of an ObjectId
    },
    {
      $lookup:{
        from: "videos",
        localField:  "watchHistory",
        foreignField: "_id",
        as: "watchHistory",
        pipeline:[
          {
            $lookup: {
              from: "users",
              localField: "owner",
              foreignField: "_id",
              as:  "owner",
              pipeline:[
                {
                  "$project":{
                    fullname: 1,
                    username: 1,
                    avatar: 1
                  }
                }
              ]
            }
          },
          {
            $addFields: {
              owner: {
                // $arrayElemAt: [ "$owner" , 0]
                $first: "$owner"
              }
            }
          }
        ]
      }
    }
  ])

  return res
  .status(200)
  .json(
    new apiResponse(200, user[0].watchHistory, "watch history fetched successfully")
  )
})

export { registerUser, loginUser, logoutUser, refreshAccessToken, changeCurrentPassword, getCurrentUser, updateAccountDetails, updateUserAvatar, updateUserCoverImage, getUserChannelProfile, getWatchHistory };
